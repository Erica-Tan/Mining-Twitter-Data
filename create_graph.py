#Aim - Program to read the logs generated by YCSB and generate the graphs for read latency, update latency and throughput
#Assumption - File Name of logs should be XXXXrunYYYY_ZZZZ.out
#XXXX - DBName
#YYYY - Desired Throughput
#ZZZZ - Threads

import settings
import os
import re
from os.path import isfile, join
from matplotlib import pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns



def readFiles(floder):	
	cwd = settings.YCSB_LOGS_DIR+'/'+floder
	lst = {}
	for f in os.listdir(cwd):
		fpath = join(cwd,f)
		if isfile(fpath) and f[-3:] == "out":		
			rindex = f.find("run")
			uindex = f.find("_")
			dtype, dthroughput, dthread, workload  = f[:rindex],int(f[rindex+3:uindex]),int(f[uindex+1:-6]),f[-5:-4]
			otregex = re.compile("^\[OVERALL.*Throughput.*",re.M);
			ulregex = re.compile("^\[UPDATE.*AverageLatency.*",re.M);
			rlregex = re.compile("^\[READ.*AverageLatency.*",re.M);
			rtregex = re.compile("^\[OVERALL.*RunTime.*",re.M);
			strfile = open(fpath,"r").read()
			otline  = otregex.search(strfile)
			ulline  = ulregex.search(strfile)
			rlline  = rlregex.search(strfile)
			rtline  = rtregex.search(strfile)
			
			throughput = float(otline.group(0).split(",")[2])
			runtime = float(rtline.group(0).split(",")[2])
			ulatency = float(ulline.group(0).split(",")[2]) if ulline else 0
			rlatency = float(rlline.group(0).split(",")[2]) if rlline else 0
				
			if not dtype in dict.keys(lst):
				lst[dtype] = {}
								
			lst[dtype][dthroughput] = [ulatency,rlatency,throughput,runtime]		

	
	nlst = {}
	for dtype in lst:
		nlst[dtype] = []
		for i in range(0,5):
			nlst[dtype].append([])
		for th in sorted(lst[dtype]):
			nlst[dtype][0].append(th)
			nlst[dtype][1].append(lst[dtype][th][0])
			nlst[dtype][2].append(lst[dtype][th][1])
			nlst[dtype][3].append(lst[dtype][th][2])
			nlst[dtype][4].append(lst[dtype][th][3])
			
	
	return nlst

#This function saves the plot in a file
#This is contributed by Siddharth Goel (National University of Singapore)
def save(path, ext='png', close=True, verbose=True):

	# Extract the directory and filename from the given path
	directory = os.path.split(path)[0]
	filename = "%s.%s" % (os.path.split(path)[1], ext)
	if directory == '':
		directory = '.'

	# If the directory does not exist, create it
	if not os.path.exists(directory):
		os.makedirs(directory)

	# The final path to save to
	savepath = os.path.join(directory, filename)

	if verbose:
		print("Saving figure to '%s'..." % savepath)

	#pp.gcf().set_size_inches(18.5,10.5)

	# Actually save the figure
	#pp.savefig(savepath, figsize=(50, 40), dpi=80)

	plt.savefig(savepath)

	# Close it
	if close:
		plt.close()

	if verbose:
		print("Done")

def createlineGraph(data, xlabel, ylabel, title, filename, key):

	sns.set_style("darkgrid")

	results = {'x': [], 'y': [], 'Databases':[]}

	for dtype in sorted(data.keys()):
		
		results['x'].extend(data[dtype][0])
		results['y'].extend(data[dtype][key])
		results['Databases'].extend([dtype for i in range(len(data[dtype][0]))])
				

	df = pd.DataFrame(results)

	ax = sns.pointplot(x="x", y="y", hue="Databases", data=df)
	plt.xlabel(xlabel)
	plt.ylabel(ylabel)
	plt.title(title)
	#plt.show()

	save(settings.TESTING_PLOT_DIR + '/'+filename)


def createBarGraph(data, ylabel, title, filename, key):

	results = {'database':[], 'performance':[]}

	for dtype in sorted(data.keys()):
		results['database'].append(dtype)
		results['performance'].append(data[dtype][key][0])


	sns.set(font_scale=1.5)
	sns.barplot(x='database', y='performance', data=results)
	

	pp.ylabel(ylabel)
	pp.title(title)
	#pp.show()

	save(settings.TESTING_PLOT_DIR + '/'+filename)



def main():

	#Read the log files
	data = readFiles('workloada')


	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Average Update Latency (us)'
	title = 'Update Latency - Workload A'
	filename = 'update_latency_workloada_line'
	key = 1
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)


	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Average Read Latency (us)'
	title = 'Read Latency - Workload A'
	filename = 'read_latency_workloada_line'
	key = 2
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)

	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Throughput (ops/sec)'
	title = 'Throughput - Workload A'
	filename = 'throughput_workloada_line'
	key = 3
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)


	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Runtime (ms)'
	title = 'Runtime - Workload A'
	filename = 'runtime_workloada_line'
	key = 4

	createlineGraph(data, xlabel, ylabel, title, filename, key)

	'''
	#Read the log files
	data = readFiles('workloadc')

	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Average Read Latency (us)'
	title = 'Read Latency - Workload C'
	filename = 'read_latency_workloadc_line'
	key = 2
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)

	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Throughput (ops/sec)'
	title = 'Throughput - Workload C'
	filename = 'throughput_workloadc_line'
	key = 3
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)


	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Runtime (ms)'
	title = 'Runtime - Workload C'
	filename = 'runtime_workloadc_line'
	key = 4
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)

	

	#Read the log files
	data = readFiles('workloadg')
	
	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Average Insert Latency (us)'
	title = 'Insert Latency - Workload G'
	filename = 'insert_latency_workloadg_line'
	key = 2
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)

	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Throughput (ops/sec)'
	title = 'Throughput - Workload G'
	filename = 'throughput_workloadg_line'
	key = 3
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)

	xlabel = 'Target Throughput (ops/sec)'
	ylabel = 'Overall Runtime (ms)'
	title = 'Runtime - Workload G'
	filename = 'runtime_workloadg_line'
	key = 4
	
	createlineGraph(data, xlabel, ylabel, title, filename, key)
	'''



if __name__=="__main__":
	main()



